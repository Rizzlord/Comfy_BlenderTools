import os
import sys
import tempfile
import traceback
import trimesh as trimesh_loader
import folder_paths
import numpy as np
import torch
from PIL import Image
from .utils import _run_blender_script, get_blender_clean_mesh_func_script

class VertexToHighPoly:
    PROJECTION_MODES = ["orthographic", "perspective"]

    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "high_poly_mesh": ("TRIMESH",),
                "multiview_images": ("IMAGE",),
                "projection_mode": (cls.PROJECTION_MODES, {"default": "orthographic"}),
                "blend_sharpness": ("FLOAT", {"default": 4.0, "min": 0.1, "max": 16.0, "step": 0.1}),
                "perspective_fov": ("FLOAT", {"default": 50.0, "min": 1.0, "max": 120.0, "step": 0.1}),
                "orthographic_width": ("FLOAT", {"default": 1.0, "min": 0.1, "max": 10.0, "step": 0.01}),
                "orthographic_height": ("FLOAT", {"default": 1.0, "min": 0.1, "max": 10.0, "step": 0.01}),
                "perspective_width": ("FLOAT", {"default": 1.0, "min": 0.1, "max": 10.0, "step": 0.01}),
                "perspective_height": ("FLOAT", {"default": 1.0, "min": 0.1, "max": 10.0, "step": 0.01}),
            },
            "optional": {
                "camera_config": ("HY3DCAMERA",),
            }
        }

    RETURN_TYPES = ("TRIMESH",)
    RETURN_NAMES = ("high_poly_mesh",)
    FUNCTION = "project"
    CATEGORY = "Comfy_BlenderTools/VertexBake"

    def project(self, high_poly_mesh, multiview_images, projection_mode, blend_sharpness, perspective_fov, 
                orthographic_width, orthographic_height, perspective_width, perspective_height, camera_config=None):
        
        images_pil = [Image.fromarray((img.cpu().numpy() * 255).astype(np.uint8)) for img in multiview_images]

        if not images_pil:
            raise ValueError("No images provided for projection.")

        if camera_config:
            camera_azims = camera_config.get("selected_camera_azims", [0, 90, 180, 270, 0, 180])
            camera_elevs = camera_config.get("selected_camera_elevs", [10, -10, 10, -10, 90, -90])
            cam_distance = camera_config.get("camera_distance", 1.45)
            ortho_scale_mult = camera_config.get("ortho_scale", 1.2)
        else:
            camera_azims = [0, 90, 180, 270, 0, 180]
            camera_elevs = [10, -10, 10, -10, 90, -90]
            cam_distance = 1.45
            ortho_scale_mult = 1.2

        if len(images_pil) != len(camera_azims):
            raise ValueError(f"Number of images ({len(images_pil)}) does not match number of camera views ({len(camera_azims)}).")

        with tempfile.TemporaryDirectory() as temp_dir:
            high_poly_path = os.path.join(temp_dir, "high.obj")
            final_high_poly_path = os.path.join(temp_dir, "final_high.glb")
            script_path = os.path.join(temp_dir, "s.py")
            image_paths = []
            
            # Save images to temp directory
            for i, img_pil in enumerate(images_pil):
                image_path = os.path.join(temp_dir, f"mv_{i}.png")
                img_pil.save(image_path)
                image_paths.append(image_path)

            high_poly_mesh.export(file_obj=high_poly_path)

            params = {
                'high_poly_path': high_poly_path,
                'final_high_poly_path': final_high_poly_path,
                'temp_dir': temp_dir,
                'image_paths': image_paths,
                'camera_azims': camera_azims,
                'camera_elevs': camera_elevs,
                'cam_distance': cam_distance,
                'ortho_scale_mult': ortho_scale_mult,
                'projection_mode': projection_mode,
                'blend_sharpness': blend_sharpness,
                'perspective_fov': perspective_fov,
                'orthographic_width': orthographic_width,
                'orthographic_height': orthographic_height,
                'perspective_width': perspective_width,
                'perspective_height': perspective_height,
            }

            clean_mesh_func_script = get_blender_clean_mesh_func_script()

            script = f"""
{clean_mesh_func_script}
import bpy, sys, os, traceback, math
from mathutils import Vector

p = {{ {", ".join(f'"{k}": r"{v}"' if isinstance(v, str) else f'"{k}": {v}' for k, v in params.items())} }}

def setup_scene():
    bpy.ops.wm.read_factory_settings(use_empty=True)
    bpy.context.scene.render.engine = 'CYCLES'
    bpy.context.scene.cycles.samples = 1
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete(use_global=False)
    bpy.context.scene.render.bake.margin = 0
    bpy.context.scene.render.bake.use_clear = False

def import_mesh():
    bpy.ops.wm.obj_import(filepath=p['high_poly_path'])
    high_obj = bpy.context.selected_objects[0]
    high_obj.name = "HighPoly"
    
    # Ensure vertex color layer exists
    if not high_obj.data.vertex_colors:
        high_obj.data.vertex_colors.new(name="Col")
    else:
        # Use existing vertex color layer
        high_obj.data.vertex_colors.active = high_obj.data.vertex_colors[0]
        high_obj.data.vertex_colors.active.name = "Col"
    
    clean_mesh(high_obj, 0.0001)
    return high_obj

def create_material_with_vertex_color():
    mat = bpy.data.materials.new(name="VertexColorMaterial")
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    links = mat.node_tree.links
    nodes.clear()
    
    # Create nodes
    output_node = nodes.new(type='ShaderNodeOutputMaterial')
    emission_node = nodes.new(type='ShaderNodeEmission')
    vertex_color_node = nodes.new(type='ShaderNodeVertexColor')
    vertex_color_node.layer_name = "Col"
    
    # Connect nodes
    links.new(vertex_color_node.outputs['Color'], emission_node.inputs['Color'])
    links.new(emission_node.outputs['Emission'], output_node.inputs['Surface'])
    
    return mat

def project_textures_to_vertex_colors(obj):
    # Setup material with vertex color
    mat = create_material_with_vertex_color()
    if obj.data.materials:
        obj.data.materials[0] = mat
    else:
        obj.data.materials.append(mat)
    
    # Get object's bounding box for camera setup
    bbox = [obj.matrix_world @ Vector(corner) for corner in obj.bound_box]
    center = sum(bbox, Vector()) / len(bbox)
    max_extent = max((bbox[i] - bbox[(i+1)%len(bbox)]).length for i in range(len(bbox)))
    
    # Create cameras for each view
    cameras = []
    for i, (azim, elev) in enumerate(zip(p['camera_azims'], p['camera_elevs'])):
        # Create camera
        bpy.ops.object.camera_add()
        cam = bpy.context.active_object
        cam.name = f"Camera_{i}"
        cam.data.type = 'ORTHO' if p['projection_mode'] == 'orthographic' else 'PERSP'
        
        # Set camera properties
        if p['projection_mode'] == 'orthographic':
            cam.data.ortho_scale = max(p['orthographic_width'], p['orthographic_height']) * p['ortho_scale_mult']
        else:
            cam.data.lens = p['perspective_fov']
        
        # Position camera
        azim_rad = math.radians(azim)
        elev_rad = math.radians(elev)
        x = center.x + p['cam_distance'] * math.cos(elev_rad) * math.sin(azim_rad)
        y = center.y + p['cam_distance'] * math.sin(elev_rad)
        z = center.z + p['cam_distance'] * math.cos(elev_rad) * math.cos(azim_rad)
        cam.location = (x, y, z)
        cam.rotation_mode = 'QUATERNION'
        look_at = center - cam.location
        cam.rotation_quaternion = look_at.to_track_quat('-Z', 'Y')
        
        cameras.append(cam)
    
    # Create image planes for each view
    for i, (image_path, camera) in enumerate(zip(p['image_paths'], cameras)):
        # Load image
        try:
            img = bpy.data.images.load(image_path)
        except Exception as ex:
            print(f"Failed to load image {{image_path}}: {{ex}}")
            continue
            
        # Create plane
        bpy.ops.mesh.primitive_plane_add(size=1)
        plane = bpy.context.active_object
        plane.name = f"ImagePlane_{{i}}"
        
        # Scale plane to match camera view
        if p['projection_mode'] == 'orthographic':
            # Orthographic scale directly controls plane size
            plane.scale = (camera.data.ortho_scale, camera.data.ortho_scale, 1)
        else:
            # Calculate plane size based on perspective FOV
            fov_rad = math.radians(p['perspective_fov'])
            distance = p['cam_distance']
            plane_size = 2 * distance * math.tan(fov_rad / 2)
            plane.scale = (plane_size, plane_size, 1)
        
        # Position plane
        plane.location = camera.location
        plane.rotation_mode = 'QUATERNION'
        plane.rotation_quaternion = camera.rotation_quaternion
        
        # Create material for image plane
        img_mat = bpy.data.materials.new(name=f"ImageMaterial_{{i}}")
        img_mat.use_nodes = True
        img_nodes = img_mat.node_tree.nodes
        img_links = img_mat.node_tree.links
        img_nodes.clear()
        
        # Create nodes
        img_output = img_nodes.new(type='ShaderNodeOutputMaterial')
        img_emission = img_nodes.new(type='ShaderNodeEmission')
        img_tex = img_nodes.new(type='ShaderNodeTexImage')
        img_tex.image = img
        
        # Connect nodes
        img_links.new(img_tex.outputs['Color'], img_emission.inputs['Color'])
        img_links.new(img_emission.outputs['Emission'], img_output.inputs['Surface'])
        
        # Assign material to plane
        if plane.data.materials:
            plane.data.materials[0] = img_mat
        else:
            plane.data.materials.append(img_mat)
        
        # Setup render settings for this view
        bpy.context.scene.camera = camera
        bpy.context.scene.render.resolution_x = img.size[0]
        bpy.context.scene.render.resolution_y = img.size[1]
        bpy.context.scene.render.resolution_percentage = 100
        bpy.context.scene.render.image_settings.file_format = 'PNG'
        
        # Setup vertex color bake
        bpy.context.view_layer.objects.active = obj
        obj.select_set(True)
        
        # Perform bake - FIXED: Correct parameters for Blender 4.0+
        bpy.context.scene.cycles.bake_type = 'DIFFUSE'
        bpy.context.scene.render.bake.use_selected_to_active = True
        bpy.context.scene.render.bake.use_cage = False
        bpy.context.scene.render.bake.cage_extrusion = 0.0
        bpy.context.scene.render.bake.max_ray_distance = 0.0
        bpy.context.scene.render.bake.margin = 0
        
        # Correct bake call for Blender 4.0+ - using string format for pass_filter
        try:
            bpy.ops.object.bake(
                type='DIFFUSE',
                pass_filter=set(['COLOR']),
                use_clear=False
            )
        except Exception as e:
            print(f"Bake failed for view {{i}}: {{str(e)}}")
            continue
        
        # Clean up
        bpy.data.objects.remove(plane, do_unlink=True)
        bpy.data.images.remove(img)
    
    # Clean up cameras
    for cam in cameras:
        bpy.data.objects.remove(cam, do_unlink=True)

try:
    setup_scene()
    high_obj = import_mesh()
    
    # Setup render settings
    bpy.context.scene.render.engine = 'CYCLES'
    bpy.context.scene.cycles.samples = 1
    bpy.context.scene.cycles.max_bounces = 0
    bpy.context.scene.view_settings.view_transform = 'Standard'
    bpy.context.scene.display_settings.display_device = 'sRGB'
    bpy.context.scene.sequencer_colorspace_settings.name = 'sRGB'
    
    project_textures_to_vertex_colors(high_obj)
    
    # Clean mesh after baking
    clean_mesh(high_obj, 0.0)
    
    # Export final mesh
    bpy.ops.object.select_all(action='DESELECT')
    high_obj.select_set(True)
    bpy.ops.export_scene.gltf(filepath=p['final_high_poly_path'], export_format='GLB', use_selection=True)
    sys.exit(0)
except Exception as e:
    print(f"Blender script failed: {{e}}", file=sys.stderr)
    traceback.print_exc(file=sys.stderr)
    sys.exit(1)
"""
            with open(script_path, 'w') as f:
                f.write(script)

            _run_blender_script(script_path)
            
            # Load the final mesh with vertex colors
            final_mesh = trimesh_loader.load(final_high_poly_path, force="mesh")
            return (final_mesh,)

class VertexToLowPoly:
    BLEED_METHODS = ["distance", "dilate"]
    SUPERSAMPLE_OPTIONS = ["1x", "2x", "4x"]
    BAKING_MODES = ["Nearest Neighbor", "Raycast"]
    BAKE_TYPES = ["Color", "Emit"]

    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "high_poly_mesh": ("TRIMESH",),
                "low_poly_mesh": ("TRIMESH",),
                "texture_resolution": ("INT", {"default": 2048, "min": 256, "max": 8192, "step": 256}),
                "bake_type": (cls.BAKE_TYPES, {"default": "Color"}),
                "baking_method": (cls.BAKING_MODES, {"default": "Nearest Neighbor"}),
                "seam_bleed": ("INT", {"default": 16, "min": 0, "max": 64, "step": 1}),
                "bleed_method": (cls.BLEED_METHODS, {"default": "distance"}),
                "supersampling": (cls.SUPERSAMPLE_OPTIONS, {"default": "1x"}),
            }
        }

    RETURN_TYPES = ("TRIMESH", "IMAGE",)
    RETURN_NAMES = ("low_poly_mesh", "baked_texture",)
    FUNCTION = "bake"
    CATEGORY = "Comfy_BlenderTools/VertexBake"

    def bake(self, high_poly_mesh, low_poly_mesh, texture_resolution, bake_type, baking_method, seam_bleed, bleed_method, supersampling):
        with tempfile.TemporaryDirectory() as temp_dir:
            high_poly_path = os.path.join(temp_dir, "high.obj")
            low_poly_path = os.path.join(temp_dir, "low.obj")
            final_low_poly_path = os.path.join(temp_dir, "final_low.glb")
            baked_texture_path = os.path.join(temp_dir, "baked_texture.png")
            script_path = os.path.join(temp_dir, "s.py")

            high_poly_mesh.export(file_obj=high_poly_path)
            low_poly_mesh.export(file_obj=low_poly_path)

            params = {
                'high_poly_path': high_poly_path,
                'low_poly_path': low_poly_path,
                'final_low_poly_path': final_low_poly_path,
                'baked_texture_path': baked_texture_path,
                'temp_dir': temp_dir,
                'texture_resolution': texture_resolution,
                'bake_type': bake_type,
                'baking_method': baking_method,
                'seam_bleed': seam_bleed,
                'bleed_method': bleed_method,
                'supersampling': supersampling,
            }

            clean_mesh_func_script = get_blender_clean_mesh_func_script()

            script = f"""
{clean_mesh_func_script}
import bpy, sys, os, traceback
p = {{ {", ".join(f'"{k}": r"{v}"' if isinstance(v, str) else f'"{k}": {v}' for k, v in params.items())} }}

def setup_scene():
    bpy.ops.wm.read_factory_settings(use_empty=True)
    bpy.context.scene.render.engine = 'CYCLES'
    bpy.context.scene.cycles.samples = 1
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete(use_global=False)
    bpy.context.scene.render.bake.margin = int(p['seam_bleed'])
    bpy.context.scene.render.bake.use_clear = False

def import_meshes():
    bpy.ops.wm.obj_import(filepath=p['high_poly_path'])
    high_obj = bpy.context.selected_objects[0]
    high_obj.name = "HighPoly"
    clean_mesh(high_obj, 0.0001)

    bpy.ops.wm.obj_import(filepath=p['low_poly_path'])
    low_obj = bpy.context.selected_objects[0]
    low_obj.name = "LowPoly"
    clean_mesh(low_obj, 0.0001)
    
    # Ensure low poly has UV map
    if not low_obj.data.uv_layers:
        bpy.context.view_layer.objects.active = low_obj
        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.uv.unwrap(method='ANGLE_BASED', fill_hole=True)
        bpy.ops.object.mode_set(mode='OBJECT')
    
    return high_obj, low_obj

def setup_highpoly_material(high_obj):
    # Create material for high poly with vertex color
    mat = bpy.data.materials.new(name="HighPolyMaterial")
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    links = mat.node_tree.links
    nodes.clear()
    
    # Create nodes
    output_node = nodes.new(type='ShaderNodeOutputMaterial')
    bsdf_node = nodes.new(type='ShaderNodeBsdfPrincipled')
    vertex_color_node = nodes.new(type='ShaderNodeVertexColor')
    vertex_color_node.layer_name = "Col"  # Must match vertex color layer name
    
    # Connect nodes
    links.new(vertex_color_node.outputs['Color'], bsdf_node.inputs['Base Color'])
    links.new(bsdf_node.outputs['BSDF'], output_node.inputs['Surface'])
    
    # Assign material to high poly
    if high_obj.data.materials:
        high_obj.data.materials[0] = mat
    else:
        high_obj.data.materials.append(mat)
    
    return mat

def setup_lowpoly_material(low_obj):
    # Create material for low poly with image texture
    mat = bpy.data.materials.new(name="LowPolyMaterial")
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    links = mat.node_tree.links
    nodes.clear()
    
    # Create nodes
    output_node = nodes.new(type='ShaderNodeOutputMaterial')
    bsdf_node = nodes.new(type='ShaderNodeBsdfPrincipled')
    tex_node = nodes.new('ShaderNodeTexImage')
    
    # Create new image for baking
    res = int(p['texture_resolution'])
    bake_image = bpy.data.images.new(
        name="BakeImage", 
        width=res, 
        height=res, 
        alpha=True,
        float_buffer=False
    )
    tex_node.image = bake_image
    
    # Connect nodes
    links.new(tex_node.outputs['Color'], bsdf_node.inputs['Base Color'])
    links.new(bsdf_node.outputs['BSDF'], output_node.inputs['Surface'])
    
    # Assign material to low poly
    if low_obj.data.materials:
        low_obj.data.materials[0] = mat
    else:
        low_obj.data.materials.append(mat)
    
    # Make texture node active for baking
    nodes.active = tex_node
    
    return mat, tex_node, bake_image

def bake_vertex_colors_to_texture(high_obj, low_obj, tex_node, bake_image):
    # Select objects
    bpy.ops.object.select_all(action='DESELECT')
    high_obj.select_set(True)
    low_obj.select_set(True)
    bpy.context.view_layer.objects.active = low_obj
    
    # Setup bake settings
    bpy.context.scene.render.bake.use_selected_to_active = True
    bpy.context.scene.render.bake.use_cage = False
    bpy.context.scene.render.bake.cage_extrusion = 0.0
    bpy.context.scene.render.bake.max_ray_distance = 0.0
    bpy.context.scene.render.bake.margin = int(p['seam_bleed'])
    
    # Perform bake based on type - FIXED: Correct parameters for Blender 4.0+
    if p['bake_type'] == 'Color':
        # Bake vertex colors as pure color (no lighting)
        bpy.context.scene.cycles.bake_type = 'DIFFUSE'
        try:
            # Use string format to avoid f-string interpretation issues
            bpy.ops.object.bake(
                type='DIFFUSE',
                pass_filter=set(['COLOR']),
                use_clear=False
            )
        except Exception as e:
            print(f"Color bake failed: {{str(e)}}")
    else:  # Emit
        try:
            bpy.ops.object.bake(type='EMIT')
        except Exception as e:
            print(f"Emit bake failed: {{str(e)}}")
    
    # Save baked image
    bake_image.filepath_raw = p['baked_texture_path']
    bake_image.file_format = 'PNG'
    bake_image.save()

try:
    setup_scene()
    high_obj, low_obj = import_meshes()
    
    # Setup materials
    setup_highpoly_material(high_obj)
    low_poly_mat, tex_node, bake_image = setup_lowpoly_material(low_obj)
    
    # Perform baking
    bake_vertex_colors_to_texture(high_obj, low_obj, tex_node, bake_image)
    
    # Clean meshes
    clean_mesh(high_obj, 0.0)
    clean_mesh(low_obj, 0.0)
    
    # Export final mesh
    bpy.ops.object.select_all(action='DESELECT')
    low_obj.select_set(True)
    bpy.ops.export_scene.gltf(filepath=p['final_low_poly_path'], export_format='GLB', use_selection=True)
    sys.exit(0)
except Exception as e:
    print(f"Blender script failed: {{e}}", file=sys.stderr)
    traceback.print_exc(file=sys.stderr)
    sys.exit(1)
"""
            with open(script_path, 'w') as f:
                f.write(script)

            _run_blender_script(script_path)
            
            # Load the final mesh
            final_mesh = trimesh_loader.load(final_low_poly_path, force="mesh")
            
            # Load the baked texture
            if os.path.exists(baked_texture_path):
                baked_texture_pil = Image.open(baked_texture_path).convert('RGB')
                baked_texture_tensor = torch.from_numpy(np.array(baked_texture_pil).astype(np.float32) / 255.0)[None,]
            else:
                # Create a dummy tensor if baking failed
                baked_texture_tensor = torch.zeros((1, 64, 64, 3), dtype=torch.float32)
            
            return (final_mesh, baked_texture_tensor,)